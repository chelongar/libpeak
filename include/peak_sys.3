.Dd November 25, 2012
.Dt PEAK_SYS 3
.Os
.Sh NAME
.Nm peak_spin_init ,
.Nm peak_spin_lock ,
.Nm peak_spin_unlock ,
.Nm peak_spin_exit ,
.Nm peak_barrier_init ,
.Nm peak_parrier_wait ,
.Nm peak_parrier_wake ,
.Nm peak_barrier_join ,
.Nm peak_barrier_leave ,
.Nm peak_barrier_exit
.Nd synchonization wrappers
.Sh SYNOPSIS
.Fd #include <peak.h>
.Ft void
.Fn peak_spin_init "peak_spinlock_t *lock"
.Ft void
.Fn peak_spin_lock "peak_spinlock_t *lock"
.Ft void
.Fn peak_spin_unlock "peak_spinlock_t *lock"
.Ft void
.Fn peak_spin_exit "peak_spinlock_t *lock"
.Ft void
.Fn peak_barrier_init "peak_barrier_t *barrier"
.Ft int
.Fn peak_barrier_wait "peak_barrier_t *barrier"
.Ft void
.Fn peak_barrier_wake "peak_barrier_t *barrier"
.Ft int
.Fn peak_barrier_join "peak_barrier_t *barrier"
.Ft int
.Fn peak_barrier_leave "peak_barrier_t *barrier"
.Ft void
.Fn peak_barrier_exit "peak_barrier_t *barrier"
.Sh DESCRIPTION
The
.Nm peak_sys
API provides POSIX thread-like functionality for all target
operating systems. In particular, it implements spinlocks
and customized barriers. Please be aware that both types can
produce deadlock scenarios if you don't adhere to the given
instructions.
.Sh SPINLOCKS
The spinlocks are of type
.Fa peak_spinlock_t ,
which must be provided by the caller. Invoking
.Fn peak_spinlock_init
yields a usable lock, which can be operated by subsequent calls of
.Fn peak_spin_lock
and
.Fn peak_spin_unlock .
The lock can be destroyed by calling
.Fn peak_spin_exit .
Operating an uninitialized or previously destroyed spinlock yields
an undefined behavior.
.Sh BARRIERS
The implementation of barriers of type
.Fa peak_barrier_t
is a bit more complex than its POSIX equivalent. Creation via
.Fn peak_barrier_init
will initialize the barrier, but the number of threads waiting on
a barrier is dynamic. Thus, after creation, zero threads are
registered by the barrier. Waiting on such a barrier is undefined.
.Pp
Instead, the functions
.Fn peak_barrier_join
and
.Fn peak_barrier_leave
must be used to register or unregister a thread to the barrier. In
some cases, the operation may not succeed, which is indicated by the
return value of both functions. A zero return value indicates the
operation could be finished, otherwise a non-zero value is returned.
So in both cases, these functions need to be polled in order to
invoke the requested operation:
.Bd -literal -offset indent
while (peak_barrier_join(&barrier)) {
	msleep(1);
}
.Ed
.Pp
In case of leaving a barrier, care must be taken to invoke the
internal barrier synchronization mechanism as long as the thread
cannot leave the barrier:
.Bd -literal -offset indent
while (peak_barrier_leave(&barrier)) {
	wait_and_wake_if_needed(&barrier);
}
.Ed
.Pp
The acutal barrier synchronization mechanism is implemented using
.Fn peak_barrier_wait
and
.Fn peak_barrier_wake .
This provides another API twist: the serializing thread doesn't
block - it is in charge of calling the wake function to wake up
all other threads. To indicate this behavior,
.Fn peak_barrier_wait
returns non-zero. Otherwise, zero is returned, meaning the
serialization was complete and all threads have been woken up.
The code may look like so:
.Bd -literal -offset indent
if (needed) {
	/* all threads invoke barrier wait */
	if (peak_barrier_wait(&barrier)) {
		/* winner gets to do all the work */
		peak_barrier_wake(&barrier);
	}
	/* all threads are awake again */
}
.Ed
.Pp
This ensures the serializing thread can do data structure
manipulations while no other thread is able to change or even
reference it, because all those threads are being blocked by
the barrier. Traditionally, this had to be implemented by
invoking a second barrier wait operation. This was considered
an unnecessary complication.
.Pp
Finally, the barrier can be destroyed by calling
.Fn peak_barrier_exit .
Operating an uninitialized or previously destroyed barrier
results in undefined behavior.
.Sh AUTHORS
.An Franco Fichtner
.Aq franco@lastsummer.de
