.\"
.\" Copyright (c) 2012-2013 Franco Fichtner <franco@packetwerk.com>
.\"
.\" Permission to use, copy, modify, and distribute this software for any
.\" purpose with or without fee is hereby granted, provided that the above
.\" copyright notice and this permission notice appear in all copies.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
.\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
.\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
.\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
.\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
.\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
.\"
.Dd November 24, 2013
.Dt PEAK_TIMESLICE 3
.Os
.Sh NAME
.Nm TIMESLICE_INIT ,
.Nm TIMESLICE_NORMALISE ,
.Nm TIMESLICE_ADVANCE
.Nd simple clock service
.Sh SYNOPSIS
.In peak.h
.Fn TIMESLICE_INIT CLOCK
.Fn TIMESLICE_NORMALISE CLOCK TS_MS
.Fn TIMESLICE_ADVANCE CLOCK TS_UNIX TS_MS
.Sh DESCRIPTION
The
.Nm peak_timeslice
macros provide a centralised clock to avoid system calls for
clock operations.
System calls are considered a bottleneck for high performance
threads, since they will invoke the scheduler and cause a context
switch to happen.
.Pp
The
.Vt timeslice_t
structure is preloaded with the current time slice's clock using
several monotonic timestamps and an
.Ux
timestamp.
Both types are needed, as most timeout functionality needs to run on a
monotonic clock, while external functionality will need the actual
time.
A
.Vt struct tm
for GMT and the local time zone are also provided.
The structure's layout is as follows:
.Bd -literal -offset indent
typedef struct {
	int64_t normal;
	int64_t msec;
	int64_t sec;
	time_t epoch;
	struct tm local;
	struct tm gmt;
} timeslice_t;
.Ed
.Pp
.Fn TIMESLICE_INIT
will prepare a
.Vt timeslice_t
for operation.
Then,
.Fn TIMESLICE_NORMALISE
is used to adjust the internal monotonic clock to start at zero,
which is quite handy for initial timeouts in other libraries.
To advance the clocks the caller invokes
.Fn TIMESLICE_ADVANCE
once per time slice.
Of course, inside the time slice, there will be no going forward
in time, but the time slices should be as small as possible anyway.
A basic loop may look like this:
.Bd -literal -offset indent
timeslice_t clock;

TIMESLICE_INIT(&clock)

update_time_values_once(&unix_value, &ms_value);
TIMESLICE_NORMALISE(&clock, ms_value);

do {
	update_time_values_once(&unix_value, &ms_value);
	TIMESLICE_ADVANCE(&clock, unix_value, ms_value);
	do_time_slice_work_now(&clock);
} while (cond);
.Ed
.Sh AUTHORS
.An Franco Fichtner Aq Mt franco@packetwerk.com
